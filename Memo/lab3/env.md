# Env構造体
## 備考
- このOSにおいてはEnv=Processという意味で使われている
## 概要
- プロセスの状態を表す構造体
- メンバ変数
    - プロセスの識別子
    - レジスタ状態を保存するための構造体(TrapFrame)
    - ページディレクトリのアドレス(仮想アドレス)
    - その他:状態を表すフラグやメタデータ保存変数など
## 実体
envsというEnv構造体の配列を用意して、それを使う    

## env_runの際
- curenvの更新
- CR3の入れ替え
- レジスタの値をTrapFrame構造体から取り出して、状態を復元する。
等をやる。

(TrapFrame構造体への値の保存は、割り込みハンドラ側でやってくれてる想定？)

# ユーザプロセス側のメモリ空間
まずはkern_pgdirを丸ごとコピーしたpgdirを作成する。(pgtableは共有してる状態)。
その後、load_icode->region_alloc->page_insertと呼び出すことによって、ユーザプログラムをロードするための仮想アドレスを物理アドレスにマップする。ここのpage_insert->pgdir_walkの流れで作られたpgtableは、このユーザプロセス用のpgdir専用となる。
## load_icode内で...
模範解答例てきなのではユーザスタックの領域の仮想アドレスのマッピングをkern_pgdirに対して行っていたが、この実装ではとりあえずはユーザプロセス用pgdirに対してマッピングを行うことにする。(231006)


# ユーザコードへの飛び方
まずmovlによって、Trapframe構造体に詰め込んだレジスタ(eipとか色々)の値をスタックに積む。
(trapframeにプロセスの情報を詰めるのは、env_allocとload_icode)

そしてpop_tframe()を呼ぶことで、セグメントレジスタの値を変更した後、iret命令を実行することで、ユーザコードへ飛ぶことができる。
## iret
iretは、スタックからEIP,CS,EFLAGS,ESP,SSを取り出して、それぞれのレジスタに値を設定する命令である。

# ユーザプログラムからの脱出
終わらないシステムコールを呼び出すことで、ユーザプログラムから脱出する。
(env_destroyシステムコール内で、ページディレクトリだけkernel用のものに戻した後、新たにmonitor()関数を呼び出している。)