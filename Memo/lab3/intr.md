# IDT(Interrupt Descriptor Table)
IDTとする領域の対応するインデックスに、ハンドラ関数のポインタを登録する。
IDT自体は、lidt命令でcpuに登録する。

IDT自体はゲートディスクリプタという構造体の配列であり、ゲートディスクリプタは、割り込みハンドラのアドレスや、割り込みの種類などを持つ。

# TSS(Task State Segment)
割り込みでユーザプログラムからカーネル側へ処理が移る時に、TSSという領域に入っている値が、カーネル側のスタックポインタになる。
この新しいスタックの上に割り込みフレーム(割り込み時にスタックに積まれるデータ構造。中身はIP,SP,CS,SS,FLAGSやエラーコードなど)が積まれる。
その後に、割り込みハンドラが呼ばれる。

割り込みフレームに積まれるIPやSPは、割り込みが起きる直前のそれらの値

# XXX descriptor(記述子)
XXXを識別するための値であり、XXX本体へアクセスするための情報を持つ。

# GDT(Global Descriptor Table)
GDTは、主にセグメントの記述子を格納するテーブルである。
テーブルの各要素は、8bitの値で、対応するセグメントの先頭アドレスと、その領域のサイズを持つ。

セグメントの記述子の他にも、TSSディスクリプタやゲートディスクリプタなども格納する。

# 例外ハンドラ
->returnで戻すのか、スケジュール系の関数で明示的に戻すのかは、OSのソフトウェアとしての設計/実装による？
<br>
josでは、各例外ハンドラをアセンブラのマクロによって、共通の処理を呼び出す別の関数として同じ場所で定義している。

## 例外ハンドラ実行中の割り込み
割り込みハンドラ実行時にIF(Interupt Flag)がクリアされるので、割り込みハンドラ実行中は割り込みが保留される。
IFはiret命令で元の処理に戻ったとき、再びセットされる。
ダブルフォールトの例外など、優先順位が高い割り込みが入った場合は、また割り込みが起こる。