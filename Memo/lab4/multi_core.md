# big kernel lock
グローバルなロックを使って排他制御を行うことで，複数のCPUで同時にカーネルを実行することを防ぐ．
各CPUのinitの関数と、trap()の中で、このロックを取得する。
env_run()の中で、このロックを解放する。

# 流れ
まず、各CPUのinit関数が順番に実行される。(lock_kernel()は、ロックを取れるまでループするようになっている。)
基本はそれぞれの関数の最後でsched_yield()を呼び出し、CPUはhltする。
これだけだと一生ユーザプログラムが実行されないので、メインのCPUのinit関数の最後とかで、シェルみたいなユーザプログラムを実行するのが良い気がする。

その後割り込みとかが発生した際に、trap()が呼ばれる、そのタイミングでlock_kernel()が呼び出される。