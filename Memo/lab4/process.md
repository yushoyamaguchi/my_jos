# fork
env_allocで子プロセスのenvを作成したのち、親プロセスのtrapframeをコピーする。
trapframeが保存されるのはシステムコールを呼んだときなので、IPにはexoforkシステムコールを呼んだ命令の次の命令のアドレスが入っている。(親プロセスのユーザプログラムの中)
よって子プロセスは、forkシステムコールが呼ばれた次の命令から実行が開始される。

exoforkシステムコール内で子プロセス用のenvのtrapframeのeaxに0を入れているので、子プロセスからしたらexoforkシステムコールの返り値が0であるように見える。


# Copy-on-Write fork
子プロセスとのメモリ空間の共有を実現するために、当初はpage_mapだけを行う。
writeが行われるとpagefaultが発生し、page_fault_handlerが呼ばれる。
そこで、page_allocとそこへのメモリコピー、page_unmapを行う。
josではこういうことを全部ユーザ空間でやるようにしているが、Linuxでもそうなのだろうか？